<div id="chart"></div>

<script src="https://d3js.org/d3.v3.js"></script>
<svg id="svg2" style="margin: 0 auto; display: block;"></svg>
<style>
    /* CSS設定 */
    .d3-tooltip {
        position: absolute;
        text-align: center;
        width: auto;
        height: auto;
        padding: 5px;
        font: 12px;
        background: white;
        border: solid 1px #aaa;
        visibility: hidden;
        z-index: 100000;
    }
</style>
<script type="text/javascript">
    var node_width = 80;
    var node_height = 30;

    var pathway_data = {{ pathway_data | tojson | safe }}
    var gene_data = {{ gene_data | tojson | safe }}
    var nodes = pathway_data["nodes"]
    var links = pathway_data["links"]
    var pathway = pathway_data["pathway"]
    var groups = pathway_data["groups"]
    var width = "{{ width }}"
    var height = "{{ height }}"


    var markerBoxSize = 10, refXFactor = 1, refYFactor = 0.5;
    var arrowPoints = [
        [markerBoxSize, markerBoxSize / 2],
        [0, markerBoxSize],
        [0, 0]
    ]
    var refX = markerBoxSize * refXFactor;
    var refY = markerBoxSize * refYFactor;

    var nodeGroups = {}; // A map like { GroupId: {minX, minY, maxX, maxY} }

    nodes.forEach(node => {
        let groupId = node.GroupRef;
        if (!groupId) {
            return;
        }
        if (nodeGroups[groupId] === undefined) {
            nodeGroups[groupId] = {
                minX: node.CenterX - node.Width / 2,
                minY: node.CenterY - node.Height / 2,
                maxX: node.CenterX + node.Width / 2,
                maxY: node.CenterY + node.Height / 2
            }
        } else {
            nodeGroups[groupId].minX = Math.min(nodeGroups[groupId].minX, node.CenterX - node.Width / 2);
            nodeGroups[groupId].minY = Math.min(nodeGroups[groupId].minY, node.CenterY - node.Height / 2);
            nodeGroups[groupId].maxX = Math.max(nodeGroups[groupId].maxX, node.CenterX + node.Width / 2);
            nodeGroups[groupId].maxY = Math.max(nodeGroups[groupId].maxY, node.CenterY + node.Height / 2);
        }
    });

    var groupMargin = 10;

    function arrowHeadType(gpmlArrowType) {
        switch (gpmlArrowType) {
            case "Arrow":
            case "mim-conversion":
                return "url(#marker-arrow)"; // -▶
            case "mim-catalysis":
                return "url(#marker-circle)"; // -◯
            case "mim-inhibition":
                return "url(#marker-pipe)"; // -|
            case "mim-modification":
                return "url(#marker-open-arrow)"; // ->
        }
        return '';
    }

    var svg = d3.select("#svg2")
        .attr("width", width)
        .attr("height", height)
        .style("background-color", "#fff");

    var titleOffset = 50;


    for (let group of groups) {
        if (nodeGroups[group.GroupId]) {
            let range = nodeGroups[group.GroupId];
            svg.append("rect")
                .attr("class", "group-rect")
                .attr("x", range.minX - groupMargin)
                .attr("y", range.minY - groupMargin + titleOffset)
                .attr("width", range.maxX - range.minX + groupMargin * 2)
                .attr("height", range.maxY - range.minY + groupMargin * 2)
                .attr("fill", "#f6f6ee")
                .attr("stroke", "gray")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "5,5")
        }
    }

    links.forEach(link => {
        link.pointsAfterOffset = [
            { X: link.points[0].X + link.points[0].RelX, Y: link.points[0].Y + link.points[0].RelY },
            { X: link.points[1].X + link.points[1].RelX, Y: link.points[1].Y + link.points[1].RelY }
        ];
        if (link.points[0].ArrowHead === "mim-inhibition" || link.points[1].ArrowHead === "mim-inhibition") {
            let length = Math.sqrt(Math.pow(link.points[1].X - link.points[0].X, 2) + Math.pow(link.points[1].Y - link.points[0].Y, 2));
            let cosine = (link.points[1].X - link.points[0].X) / length;
            let sine = (link.points[1].Y - link.points[0].Y) / length;

            if (link.points[0].ArrowHead === "mim-inhibition") {
                link.pointsAfterOffset[0].X += cosine * markerBoxSize / 2;
                link.pointsAfterOffset[0].Y += sine * markerBoxSize / 2;
            } else {
                link.pointsAfterOffset[1].X -= cosine * markerBoxSize / 2;
                link.pointsAfterOffset[1].Y -= sine * markerBoxSize / 2;
            }
        }
    })

    svg.selectAll("line")
        .data(links)
        .enter().append("line")
        .attr("class", "element-in-body")
        .attr("x1", d => d.pointsAfterOffset[0].X)
        .attr("y1", d => d.pointsAfterOffset[0].Y)
        .attr("x2", d => d.pointsAfterOffset[1].X)
        .attr("y2", d => d.pointsAfterOffset[1].Y)
        .attr('stroke', 'black')
        .attr("marker-start", d => arrowHeadType(d.points[0].ArrowHead))
        .attr("marker-end", d => arrowHeadType(d.points[1].ArrowHead))
        .attr("stroke-dasharray", d => d.Graphics?.LineStyle === "Broken" ? "5,5" : null)
        .attr('fill', 'none');


    var nodeRoundRadius = 10;

    svg.selectAll("rect.node-rect")
        .data(nodes)
        .enter().append("rect")
        .attr("class", "element-in-body node-rect")
        .attr("x", (d) => d.CenterX - d.Width / 2)
        .attr("y", (d) => d.CenterY - d.Height / 2)
        .attr("width", d => d.Width)
        .attr("height", d => d.Height)
        .attr("rx", d => d.ShapeType === "RoundRectangle" ? nodeRoundRadius : 0)
        .attr("ry", d => d.ShapeType === "RoundRectangle" ? nodeRoundRadius : 0)
        .attr("fill", "white")
        .style("stroke", d => `#${d.Color}`)
        .on("click", function (d) {
            onIdClicked(d[2])
        });


    var contentGroup = svg.append("g")
        .attr("class", "content-group")
        .attr("transform", "translate(0," + titleOffset + ")");

    svg.selectAll(".element-in-body")
        .each(function () {
            contentGroup.node().appendChild(this);
        });

    svg
        .append("defs")
        .append("marker")
        .attr("id", "marker-arrow")
        .attr("viewBox", [0, 0, markerBoxSize, markerBoxSize])
        .attr("refX", refX)
        .attr("refY", refY)
        .attr("markerWidth", markerBoxSize)
        .attr("markerHeight", markerBoxSize)
        .attr("orient", "auto-start-reverse")
        .append("path")
        .attr("d", `M ${markerBoxSize} ${markerBoxSize / 2} L 0 ${markerBoxSize} L 0 0 z`)
        .attr("fill", "#000000");


    svg
        .append("defs")
        .append("marker")
        .attr("id", "marker-circle")
        .attr("viewBox", [0, 0, markerBoxSize, markerBoxSize])
        .attr("refX", refX)
        .attr("refY", refY)
        .attr("markerWidth", markerBoxSize)
        .attr("markerHeight", markerBoxSize)
        .attr("orient", "auto-start-reverse")
        .append('circle')
        .attr('cx', markerBoxSize / 2)
        .attr('cy', markerBoxSize / 2)
        .attr('r', markerBoxSize / 2)
        .attr("stroke", "#000000")
        .attr("fill", "white");

    svg
        .append("defs")
        .append("marker")
        .attr("id", "marker-pipe")
        .attr("viewBox", [0, 0, markerBoxSize, markerBoxSize])
        .attr("refX", refX)
        .attr("refY", refY)
        .attr("markerWidth", markerBoxSize)
        .attr("markerHeight", markerBoxSize)
        .attr("orient", "auto-start-reverse")
        .append('line')
        .attr('x1', markerBoxSize)
        .attr('y1', 0)
        .attr('x2', markerBoxSize)
        .attr('y2', markerBoxSize)
        .attr("stroke", "#000000")


    svg
        .append("defs")
        .append("marker")
        .attr("id", "marker-open-arrow")
        .attr("viewBox", [0, 0, markerBoxSize, markerBoxSize])
        .attr("refX", refX)
        .attr("refY", refY)
        .attr("markerWidth", markerBoxSize)
        .attr("markerHeight", markerBoxSize)
        .attr("orient", "auto-start-reverse")
        .append("polyline")
        .attr("points", `0,0 ${markerBoxSize},${markerBoxSize / 2} 0,${markerBoxSize}`)
        .attr("fill", "transparent")
        .attr("stroke", "#000000");




    var tooltip = d3.select("body").append("div").attr("class", "d3-tooltip");

    svg.selectAll("text")
        .data(nodes)
        .enter().append("text")
        .attr("class", "element-in-body")
        .attr("x", (d) => d.CenterX)
        .attr("y", (d) => d.CenterY + titleOffset)
        .attr("stroke", d => `#${d.Color}`)
        .text(d => d.TextLabel)
        .style("text-anchor", "middle")
        .style("dominant-baseline", "central")
        .on("click", function (d) {
            onIdClicked(d.TextLabel)
        })
        .on("mouseover", function (d) {
            tooltip
                .style("visibility", "visible")
                .html(d.TextLabel);
        })
        .on("mousemove", function (d) {
            var svgRect = svg[0][0].getBoundingClientRect();
            tooltip
                .style("top", (d.CenterY + svgRect.y) + "px")
                .style("left", (d.CenterX + svgRect.x + 10) + "px");
        })
        .on("mouseout", function (d) {
            tooltip.style("visibility", "hidden");
        })



    svg.append("text")
        .attr("x", 10)
        .attr("y", 10)
        .attr("class", "pathwayName")
        .attr("stroke", "black")
        .text(`Name:${pathway.Name}`);


    svg.append("text")
        .attr("x", 10)
        .attr("y", 10)
        .attr("dy", "1.5em")
        .attr("class", "pathwayVersion")
        .attr("stroke", "black")
        .text(`Last Modified: ${pathway["Last-Modified"] || "Unknown"}`)

    svg.append("text")
        .attr("x", 10)
        .attr("y", 10)
        .attr("dy", "3em")
        .attr("class", "pathwayOrganism")
        .attr("stroke", "black")
        .text(`Organism:${pathway.Organism}`)



    var arcs = pathway_data["shapes"].filter(d => d.ShapeType == "Arc")


    svg.selectAll("path.arc")
        .data(arcs)
        .enter().append("path")
        .attr("class", "arc")
        // d3のArcでWidthとHeightを指定すると、楕円になるので、scaleで調整する
        .attr("transform", d => {
            let scaleWidth = Math.max(d.Width / d.Height, 1);
            let scaleHeight = Math.max(d.Height / d.Width, 1);
            return `translate(${d.CenterX},${d.CenterY + titleOffset}) scale(${scaleWidth},${scaleHeight})`;
        })
        .attr("d", d => {
            let width = d.Width;
            let height = d.Height;
            let radius = Math.min(width, height) / 2;
            return d3.svg.arc()({
                innerRadius: radius,
                outerRadius: radius + 1,
                startAngle: -Math.PI / 2,
                endAngle: Math.PI / 2
            })
        });


    function onIdClicked(gid) {
        // 下記の記述でグローバル変数をJupyterのPythonにわたすことはできる
        //Jupyter.notebook.kernel.execute("gid='AT5G23350'");
        //kernel.execute('graphId=10');
        Jupyter.notebook.kernel.execute(`gid='${gid}'`);


        // 相対位置でcellを指定しcellを実行する場合。フォーカスが当たっていないと実行位置がずれるため使えない
        //var cell = Jupyter.notebook.select_next().get_selected_cell()
        //cell.execute()

        // cellのindexを指定しtableのアップデートを実行する場合。設定で変更できると良いかも（必要ないかもだが）
        Jupyter.notebook.execute_cells([2])
    }
</script>